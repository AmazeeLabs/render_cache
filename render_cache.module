<?php

/**
 * @file
 * Hook implementations and frequently used functions for render cache module.
 */

/**
 * Implements hook_entity_delete().
 *
 * Delete our custom stored entity modified record when the entity is deleted.
 */
function render_cache_entity_delete($entity, $type) {
  // Attempt to delete any record we stored for the entity. We do not check
  // if it has a modified property because our knowledge of the property could
  // have occurred after we already had a record (module updates).
  db_delete('render_cache_modified')
      ->condition('entity_type', $type)
      ->condition('entity_id', $entity->{render_cache_id_name($type)})
      ->execute();
}

/**
 * Hijack entity API rendering callback to add a caching layer.
 */
function render_cache_hijack_entity_view_callback($entities, $view_mode, $langcode = NULL, $entity_type) {
  // Remove any passed values that are not an object, this can happen with out
  // of date Apache Solr search when entities are deleted and probably other
  // situations.
  foreach($entities as $key => $entity) {
    if (!is_object($entity)) {
      unset($entities[$key]);
    }
  }

  $entity_info = entity_get_info($entity_type);
  $cids = $cached = $rendered = array();
  $entity_order = array_keys($entities);

  // Store the order of the entities.
  $id = $entity_info['entity keys']['id'];
  foreach ($entities as $id => $entity) {
    $cids[$id] = render_cache_get_cid($entity_type, $entity, $view_mode, $langcode);
    // If cached then store the result and remove from $entities.
    if ($cache = cache_get($cids[$id], 'cache_render')) {
      $cached[$id] = $cache->data;
      unset($entities[$id]);
    }
  }

  // Render non-cached entities.
  if (!empty($entities)) {
    // If this is a view callback.
    if (isset($entity_info['render cache']['callback'])) {
      $rendered = $entity_info['render cache']['callback']($entities, $view_mode, $langcode, $entity_type);
      $rendered = reset($rendered);
    }
    // Otherwise this is a controller class callback.
    else {
      // We need the $page variable from entity_view() that it does not pass us.
      $backtrace = debug_backtrace();
      $page = NULL;
      // As a safety, to not grab an unexpected arg for $page, check that this
      // was called from entity_view().
      if ($backtrace[1]['function'] === 'entity_view' && isset($backtrace[0]['args'][4])) {
        $page = $backtrace[0]['args'][4];
      }
      $rendered = entity_get_controller($entity_type)->view($entities, $view_mode, $langcode, $page);
      $rendered = reset($rendered);
    }
    // Store rendered entities in cache for future views.
    foreach (element_children($rendered) as $id) {
      // Remove #weight as it will not be accurate, we weight in the cached and
      // rendered merge below.
      unset($rendered[$id]['#weight']);

      // Render and cache.
      if (variable_get('render_cache__method', 0)) {
        // Cache result as a string.
        $cached[$id] = drupal_render($rendered[$id]);
      }
      else {
        // Cache result as a render array.
        $cached[$id] = $rendered[$id];
      }
      // Store in cache.
      cache_set($cids[$id], $cached[$id], 'cache_render');
    }
  }

  // Not needed in rest of function.
  unset($entities, $rendered);

  // Return false if no entities are available, matches entity_view()'s
  // functionality.
  if (empty($cached)) {
    return FALSE;
  }

  // Put entities back in their request order and output.
  $return = array();
  if (variable_get('render_cache__method', 0)) {
    // Render entities cached as strings.
    foreach ($entity_order as $weight => $id) {
      if (isset($cached[$id])) {
        $return[$id] = array('#markup' => $cached[$id]);
        $return[$id]['#weight'] = $weight;
      }
    }
  }
  else {
    // Render entities cached as render arrays.
    foreach ($entity_order as $weight => $id) {
      if (isset($cached[$id])) {
        $return[$id] = $cached[$id];
        $return[$id]['#weight'] = $weight;
      }
    }
  }
  // Return $return, wrap with entity type key in array to match
  // entity_view()'s functionality.
  return array($entity_type => $return);
}


/**
 * Implements hook_entity_info_alter().
 *
 * We hijack entity rendering, as performed through the Entity API module, to
 * provide full entity caching.
 */
function render_cache_entity_info_alter(&$entity_info) {
  foreach ($entity_info as $type => $info) {
    if (isset($info['view callback'])) {
      // Since we are overwriting the view callback we record the original
      // callback so that we know how to render.
      $entity_info[$type]['render cache']['callback'] = $info['view callback'];
      $entity_info[$type]['view callback'] = 'render_cache_hijack_entity_view_callback';
    }
    elseif (isset($info['controller class']) &&
        in_array('EntityAPIControllerInterface', class_implements($info['controller class']))) {
      // We do not set the render cache callback, when it is missing we will
      // render using the controller class.
      $entity_info[$type]['view callback'] = 'render_cache_hijack_entity_view_callback';
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function render_cache_entity_insert($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert.
  if (!render_cache_modified_name($type)) {
    db_insert('render_cache_modified')
        ->fields(array(
          'entity_type' => $type,
          'entity_id' => $entity->{render_cache_id_name($type)},
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Implements hook_entity_update().
 */
function render_cache_entity_update($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert or update.
  if (!render_cache_modified_name($type)) {
    db_merge('render_cache_modified')
        ->key(array(
          'entity_type' => $type,
          'entity_id' => $entity->{render_cache_id_name($type)},
        ))
        ->fields(array(
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Retrieve cache ID to use for render caching.
 *
 * @param string $entity_type
 *   The type of the entity object being rendered.
 * @param object $entity
 *   The entity object being rendered.
 * @param string $view_mode
 *   The view mode the entity is being rendered through.
 * @param string|NULL $language
 *   The language the entity is being rendered in.
 *
 * @return string
 */
function render_cache_get_cid($entity_type, $entity, $view_mode, $language = NULL) {
  $hash = array();
  $admin = '';

  // Unique identifier.
  $hash['id'] = $entity->{render_cache_id_name($entity_type)};

  // Last modified timestamp.
  $modified = render_cache_modified_name($entity_type);
  if ($modified) {
    $hash['modified'] = $entity->$modified;
  }
  else {
    $hash['modified'] = db_query(
      'SELECT modified FROM {render_cache_modified} WHERE entity_type = :entity_type AND entity_id = :entity_id',
      array(':entity_type' => $entity_type, ':entity_id' => $hash['id'])
    )->fetchField();
    if (!$hash['modified']) {
      render_cache_entity_insert($entity, $entity_type);
      $hash['modified'] = REQUEST_TIME;
    }
  }

  // Language
  if (is_null($language)) {
    $hash['lang'] = $GLOBALS['language_content']->language;
  }
  else {
    $hash['lang'] = $language;
  }

  // Cache method.
  $hash['method'] = variable_get('render_cache__method', 0);

  // Allow modules to modify $hash for custom invalidating.
  $context = array(
    'entity_type' => $entity_type,
    'view_mode' => $view_mode,
    'language' => $language,
  );
  drupal_alter('render_cache_hash', $hash, $entity, $context);

  // Contextual links requires us to store two sets of caches.
  if (module_exists('contextual') && user_access('view pane admin links')) {
    $admin = 'admin:';
  }

  return 'render_cache:' . $entity_type . ':' . $view_mode . ':' . $admin . sha1(implode('-', $hash));
}

/**
 * Retrieve the unique identifying property name for use in cache ID hashing.
 *
 * @param string $entity_type
 *   The entity type to retrieve the identifier for.
 *
 * @return void|string
 *   Returns string if entity type is valid.
 */
function render_cache_id_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $names = array();

  if (isset($names[$entity_type])) {
    return $names[$entity_type];
  }
  else {
    $info = entity_get_info($entity_type);
    if (isset($info['entity keys']['revision']) && $info['entity keys']['revision']) {
      $names[$entity_type] = $info['entity keys']['revision'];
    }
    else {
      $names[$entity_type] = $info['entity keys']['id'];
    }
    return $names[$entity_type];
  }
}

/**
 * Retrieve the last modified property name for use in cache ID hashing.
 *
 * @param string $entity_type
 *   The entity type to retrieve the property name for.
 *
 * @return void|string
 *   Returns string if a property exists.
 */
function render_cache_modified_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $modified = array();

  if (empty($modified)) {
    drupal_alter('render_cache_modified_name', $modified);
  }

  if (isset($modified[$entity_type])) {
    return $modified[$entity_type];
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Moves our hook_entity_info_alter() implementation to occur last so that we
 * can consistently hijack the render function of the entity type.
 */
function render_cache_module_implements_alter(&$implementations, $hook) {
  if ($hook === 'entity_info_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['render_cache'];
    unset($implementations['render_cache']);
    $implementations['render_cache'] = $group;
  }
}

/**
 * Implements hook_render_cache_modified_name_alter().
 *
 * Eating own dog food, define unique identifiers for entity types this module
 * is aware of.
 */
function render_cache_render_cache_modified_name_alter(&$modified) {
  $modified['node'] = 'changed';
  $modified['file'] = 'timestamp';
}

/**
 * Implements hook_views_api().
 */
function render_cache_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'render_cache') . '/views',
  );
}

