<?php

/**
 * @file
 * Hook implementations and frequently used functions for render cache module.
 */

/**
 * Implements hook_entity_delete().
 *
 * Delete our custom stored entity modified record when the entity is deleted.
 */
function render_cache_entity_delete($entity, $type) {
  // Attempt to delete any record we stored for the entity. We do not check
  // if it has a modified property because our knowledge of the property could
  // have occurred after we already had a record (module updates).
  db_delete('render_cache_modified')
      ->condition('entity_type', $type)
      ->condition('entity_id', $entity->{render_cache_id_name($type)})
      ->execute();
}

/**
 * Implements hook_entity_info_alter().
 */
function render_cache_entity_info_alter(&$entity_info) {
  // Todo: We might be able to hijack node rendering by taking over the view
  // callback (or controller class with entity API).
}

/**
 * Implements hook_entity_insert().
 */
function render_cache_entity_insert($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert.
  if (!render_cache_modified_name($type)) {
    db_insert('render_cache_modified')
        ->fields(array(
          'entity_type' => $type,
          'entity_id' => $entity->{render_cache_id_name($type)},
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Implements hook_entity_update().
 */
function render_cache_entity_update($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert or update.
  if (!render_cache_modified_name($type)) {
    db_merge('render_cache_modified')
        ->key(array(
          'entity_type' => $type,
          'entity_id' => $entity->{render_cache_id_name($type)},
        ))
        ->fields(array(
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Retrieve cache ID to use for render caching.
 *
 * @param string $entity_type
 *   The type of the entity object being rendered.
 * @param object $entity
 *   The entity object being rendered.
 * @param string $view_mode
 *   The view mode the entity is being rendered through.
 * @param string|NULL $language
 *   The language the entity is being rendered in.
 *
 * @return string
 */
function render_cache_get_cid($entity_type, $entity, $view_mode, $language = NULL) {
  $hash = array();
  $admin = '';

  // Unique identifier.
  $hash['id'] = $entity->{render_cache_id_name($entity_type)};

  // Last modified timestamp.
  $modified = render_cache_modified_name($entity_type);
  if ($modified) {
    $hash['modified'] = $entity->$modified;
  }
  else {
    $hash['modified'] = db_query(
      'SELECT modified FROM {render_cache_modified} WHERE entity_type = :entity_type AND entity_id = :entity_id',
      array(':entity_type' => $entity_type, ':entity_id' => $hash['id'])
    )->fetchField();
    if (!$hash['modified']) {
      render_cache_entity_insert($entity, $entity_type);
      $hash['modified'] = REQUEST_TIME;
    }
  }

  // Language
  if (is_null($language)) {
    $hash['lang'] = $GLOBALS['language_content']->language;
  }
  else {
    $hash['lang'] = $language;
  }

  // Allow modules to modify $hash for custom invalidating.
  $context = array(
    'entity_type' => $entity_type,
    'view_mode' => $view_mode,
    'language' => $language,
  );
  drupal_alter('render_cache_hash', $hash, $entity, $context);

  // Contextual links requires us to store two sets of caches.
  if (module_exists('contextual') && user_access('view pane admin links')) {
    $admin = 'admin:';
  }

  return 'render_cache:' . $entity_type . ':' . $view_mode . ':' . $admin . sha1(implode('-', $hash));
}

/**
 * Retrieve the unique identifying property name for use in cache ID hashing.
 *
 * @param string $entity_type
 *   The entity type to retrieve the identifier for.
 *
 * @return void|string
 *   Returns string if entity type is valid.
 */
function render_cache_id_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $names = array();

  if (isset($names[$entity_type])) {
    return $names[$entity_type];
  }
  else {
    $info = entity_get_info($entity_type);
    if (isset($info['entity keys']['revision']) && $info['entity keys']['revision']) {
      $names[$entity_type] = $info['entity keys']['revision'];
    }
    else {
      $names[$entity_type] = $info['entity keys']['id'];
    }
    return $names[$entity_type];
  }
}

/**
 * Retrieve the last modified property name for use in cache ID hashing.
 *
 * @param string $entity_type
 *   The entity type to retrieve the property name for.
 *
 * @return void|string
 *   Returns string if a property exists.
 */
function render_cache_modified_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $modified = array();

  if (empty($modified)) {
    drupal_alter('render_cache_modified_name', $modified);
  }

  if (isset($modified[$entity_type])) {
    return $modified[$entity_type];
  }
}

/**
 * Implements hook_render_cache_modified_name_alter().
 *
 * Eating own dog food, define unique identifiers for entity types this module
 * is aware of.
 */
function render_cache_render_cache_modified_name_alter(&$modified) {
  $modified['node'] = 'changed';
  $modified['file'] = 'timestamp';
}

/**
 * Implements hook_views_api().
 */
function render_cache_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'render_cache') . '/views',
  );
}

